{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { useEffect, useState, useMemo, useRef } from 'react';\nimport useSize from '../useSize';\nexport default (function (list, options) {\n  var containerRef = useRef();\n  var size = useSize(containerRef); // 暂时禁止 cache\n  // const distanceCache = useRef<{ [key: number]: number }>({});\n\n  var _a = __read(useState({\n    start: 0,\n    end: 10\n  }), 2),\n      state = _a[0],\n      setState = _a[1];\n\n  var itemHeight = options.itemHeight,\n      _b = options.overscan,\n      overscan = _b === void 0 ? 5 : _b;\n\n  if (!itemHeight) {\n    console.warn('please enter a valid itemHeight');\n  }\n\n  var getViewCapacity = function getViewCapacity(containerHeight) {\n    if (typeof itemHeight === 'number') {\n      return Math.ceil(containerHeight / itemHeight);\n    }\n\n    var _a = state.start,\n        start = _a === void 0 ? 0 : _a;\n    var sum = 0;\n    var capacity = 0;\n\n    for (var i = start; i < list.length; i++) {\n      var height = itemHeight(i);\n      sum += height;\n\n      if (sum >= containerHeight) {\n        capacity = i;\n        break;\n      }\n    }\n\n    return capacity - start;\n  };\n\n  var getOffset = function getOffset(scrollTop) {\n    if (typeof itemHeight === 'number') {\n      return Math.floor(scrollTop / itemHeight) + 1;\n    }\n\n    var sum = 0;\n    var offset = 0;\n\n    for (var i = 0; i < list.length; i++) {\n      var height = itemHeight(i);\n      sum += height;\n\n      if (sum >= scrollTop) {\n        offset = i;\n        break;\n      }\n    }\n\n    return offset + 1;\n  };\n\n  var calculateRange = function calculateRange() {\n    var element = containerRef.current;\n\n    if (element) {\n      var offset = getOffset(element.scrollTop);\n      var viewCapacity = getViewCapacity(element.clientHeight);\n      var from = offset - overscan;\n      var to = offset + viewCapacity + overscan;\n      setState({\n        start: from < 0 ? 0 : from,\n        end: to > list.length ? list.length : to\n      });\n    }\n  };\n\n  useEffect(function () {\n    calculateRange();\n  }, [size.width, size.height, list.length]);\n  var totalHeight = useMemo(function () {\n    if (typeof itemHeight === 'number') {\n      return list.length * itemHeight;\n    }\n\n    return list.reduce(function (sum, _, index) {\n      return sum + itemHeight(index);\n    }, 0);\n  }, [list.length]);\n\n  var getDistanceTop = function getDistanceTop(index) {\n    // 如果有缓存，优先返回缓存值\n    // if (enableCache && distanceCache.current[index]) {\n    //   return distanceCache.current[index];\n    // }\n    if (typeof itemHeight === 'number') {\n      var height_1 = index * itemHeight; // if (enableCache) {\n      //   distanceCache.current[index] = height;\n      // }\n\n      return height_1;\n    }\n\n    var height = list.slice(0, index).reduce(function (sum, _, i) {\n      return sum + itemHeight(i);\n    }, 0); // if (enableCache) {\n    //   distanceCache.current[index] = height;\n    // }\n\n    return height;\n  };\n\n  var scrollTo = function scrollTo(index) {\n    if (containerRef.current) {\n      containerRef.current.scrollTop = getDistanceTop(index);\n      calculateRange();\n    }\n  };\n\n  var offsetTop = useMemo(function () {\n    return getDistanceTop(state.start);\n  }, [state.start]);\n  return {\n    list: list.slice(state.start, state.end).map(function (ele, index) {\n      return {\n        data: ele,\n        index: index + state.start\n      };\n    }),\n    scrollTo: scrollTo,\n    containerProps: {\n      ref: function ref(ele) {\n        containerRef.current = ele;\n      },\n      onScroll: function onScroll(e) {\n        e.preventDefault();\n        calculateRange();\n      },\n      style: {\n        overflowY: 'auto'\n      }\n    },\n    wrapperProps: {\n      style: {\n        width: '100%',\n        height: totalHeight - offsetTop,\n        marginTop: offsetTop\n      }\n    }\n  };\n});","map":{"version":3,"sources":["/Users/brandonliu/Project/goairmart/antd-demo/node_modules/ahooks/es/useVirtualList/index.js"],"names":["__read","o","n","m","Symbol","iterator","i","call","r","ar","e","next","done","push","value","error","useEffect","useState","useMemo","useRef","useSize","list","options","containerRef","size","_a","start","end","state","setState","itemHeight","_b","overscan","console","warn","getViewCapacity","containerHeight","Math","ceil","sum","capacity","length","height","getOffset","scrollTop","floor","offset","calculateRange","element","current","viewCapacity","clientHeight","from","to","width","totalHeight","reduce","_","index","getDistanceTop","height_1","slice","scrollTo","offsetTop","map","ele","data","containerProps","ref","onScroll","preventDefault","style","overflowY","wrapperProps","marginTop"],"mappings":"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","sourcesContent":["var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { useEffect, useState, useMemo, useRef } from 'react';\nimport useSize from '../useSize';\nexport default (function (list, options) {\n  var containerRef = useRef();\n  var size = useSize(containerRef); // 暂时禁止 cache\n  // const distanceCache = useRef<{ [key: number]: number }>({});\n\n  var _a = __read(useState({\n    start: 0,\n    end: 10\n  }), 2),\n      state = _a[0],\n      setState = _a[1];\n\n  var itemHeight = options.itemHeight,\n      _b = options.overscan,\n      overscan = _b === void 0 ? 5 : _b;\n\n  if (!itemHeight) {\n    console.warn('please enter a valid itemHeight');\n  }\n\n  var getViewCapacity = function getViewCapacity(containerHeight) {\n    if (typeof itemHeight === 'number') {\n      return Math.ceil(containerHeight / itemHeight);\n    }\n\n    var _a = state.start,\n        start = _a === void 0 ? 0 : _a;\n    var sum = 0;\n    var capacity = 0;\n\n    for (var i = start; i < list.length; i++) {\n      var height = itemHeight(i);\n      sum += height;\n\n      if (sum >= containerHeight) {\n        capacity = i;\n        break;\n      }\n    }\n\n    return capacity - start;\n  };\n\n  var getOffset = function getOffset(scrollTop) {\n    if (typeof itemHeight === 'number') {\n      return Math.floor(scrollTop / itemHeight) + 1;\n    }\n\n    var sum = 0;\n    var offset = 0;\n\n    for (var i = 0; i < list.length; i++) {\n      var height = itemHeight(i);\n      sum += height;\n\n      if (sum >= scrollTop) {\n        offset = i;\n        break;\n      }\n    }\n\n    return offset + 1;\n  };\n\n  var calculateRange = function calculateRange() {\n    var element = containerRef.current;\n\n    if (element) {\n      var offset = getOffset(element.scrollTop);\n      var viewCapacity = getViewCapacity(element.clientHeight);\n      var from = offset - overscan;\n      var to = offset + viewCapacity + overscan;\n      setState({\n        start: from < 0 ? 0 : from,\n        end: to > list.length ? list.length : to\n      });\n    }\n  };\n\n  useEffect(function () {\n    calculateRange();\n  }, [size.width, size.height, list.length]);\n  var totalHeight = useMemo(function () {\n    if (typeof itemHeight === 'number') {\n      return list.length * itemHeight;\n    }\n\n    return list.reduce(function (sum, _, index) {\n      return sum + itemHeight(index);\n    }, 0);\n  }, [list.length]);\n\n  var getDistanceTop = function getDistanceTop(index) {\n    // 如果有缓存，优先返回缓存值\n    // if (enableCache && distanceCache.current[index]) {\n    //   return distanceCache.current[index];\n    // }\n    if (typeof itemHeight === 'number') {\n      var height_1 = index * itemHeight; // if (enableCache) {\n      //   distanceCache.current[index] = height;\n      // }\n\n      return height_1;\n    }\n\n    var height = list.slice(0, index).reduce(function (sum, _, i) {\n      return sum + itemHeight(i);\n    }, 0); // if (enableCache) {\n    //   distanceCache.current[index] = height;\n    // }\n\n    return height;\n  };\n\n  var scrollTo = function scrollTo(index) {\n    if (containerRef.current) {\n      containerRef.current.scrollTop = getDistanceTop(index);\n      calculateRange();\n    }\n  };\n\n  var offsetTop = useMemo(function () {\n    return getDistanceTop(state.start);\n  }, [state.start]);\n  return {\n    list: list.slice(state.start, state.end).map(function (ele, index) {\n      return {\n        data: ele,\n        index: index + state.start\n      };\n    }),\n    scrollTo: scrollTo,\n    containerProps: {\n      ref: function ref(ele) {\n        containerRef.current = ele;\n      },\n      onScroll: function onScroll(e) {\n        e.preventDefault();\n        calculateRange();\n      },\n      style: {\n        overflowY: 'auto'\n      }\n    },\n    wrapperProps: {\n      style: {\n        width: '100%',\n        height: totalHeight - offsetTop,\n        marginTop: offsetTop\n      }\n    }\n  };\n});"]},"metadata":{},"sourceType":"module"}